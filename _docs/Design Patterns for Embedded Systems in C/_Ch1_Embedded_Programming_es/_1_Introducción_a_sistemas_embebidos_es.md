# Introducción a sistemas embebidos

## ¿Qué es la programación de sistemas embebidos?

Al pensar en sistemas embebidos se traza una distinción entre sistemas “embebidos” y otro tipo de sistemas. Antes de profundizar en la discusión, debemos comprender cuál es esta diferencia para que podamos apreciar lo que pse pretende con respecto a los __patrones__ y tecnologías que usaremos para desarrollar sistemas embebidos.
Se define un sistema embebido como "__un sistema computarizado dedicado a realizar un conjunto específico de funciones del mundo real, en lugar de proporcionar un entorno informático generalizado__". Claramente, se trata de una categorización amplia que incluye pequeñas computadoras de 8 bits integradas en marcapasos cardíacos, computadoras interconectadas de 32 bits que controlan la aviónica, las comunicaciones, el control de incendios de aviones y redes de área amplia compuestas por cientos de potentes sistemas informáticos para la gestión del campo de batalla en Sistemas C4ISR (Comando, Control, Comunicaciones, Computadoras, Inteligencia, Vigilancia y Reconocimiento).

Muchos sistemas embebidos no tienen discos, interfaz humana y apenas memoria, pero el alcance del mercado de sistemas embebidos es mucho más amplio que el de dispositivos tan simples.
Los sistemas embebidos están en todas partes:

- En el campo médico, los sistemas embebidos incluyen dispositivos implantables (p. ej., marcapasos cardíacos, desfibriladores y bombas de insulina), equipos de monitorización (p. ej., monitores de ECG/EKG, monitores de gases en sangre, monitores de presión arterial, monitores EMG), sistemas de imágenes (p. ej. , CT, SPECT, PET, TEM y generadores de imágenes de rayos X) y dispositivos de administración de terapia (p. ej., ventilador del paciente, vaporizadores de medicamentos y bombas de infusión).
- En el mercado de las telecomunicaciones existen dispositivos que van desde teléfonos móviles, sistemas de conmutación, enrutadores, módems y satélites.
- En entornos automotrices, los sistemas integrados optimizan la combustión del motor, administran la entrega de potencia en las transmisiones, monitorean los datos de los sensores, controlan el freno antibloqueo, brindan seguridad y ofrecen servicios de información y entretenimiento, como reproductores de CD y DVD, y enrutamiento GPS (en algunos lugares, puede ofrecer detección por radar y láser e incluso contramedidas activas por radar y láser)
- En la oficina, los sistemas integrados gestionan teléfonos, impresoras, fotocopiadoras, máquinas de fax, luces, proyectores digitales, sistemas de seguridad y sistemas de detección y extinción de incendios.
- En el hogar, por ejemplo, hornos, televisores, radios, lavadoras e incluso algunas aspiradoras.

Los sistemas integrados ya controlan, aumentan, monitorean y administran prácticamente todos los dispositivos de alta tecnología que tenemos, desde televisores hasta trenes y automatización de fábricas, y su uso va en aumento.

Un subconjunto importante de sistemas embebidos son los sistemas en tiempo real. Mucha gente tiene la impresión errónea de que "tiempo real" significa "muy rápido", pero eso no es cierto. Un sistema en tiempo real es aquel en el que se deben satisfacer restricciones de puntualidad para que el sistema sea correcto. Una categorización común, aunque simplista, de los sistemas en tiempo real es en dos grupos. Los sistemas “__duros__” en tiempo real son aquellos en los que las limitaciones de puntualidad se modelan como plazos, puntos en el tiempo en los que se requiere que se complete la ejecución de acciones específicas. Los sistemas “__blandos__” en tiempo real son aquellos que no son “__duros__”; es decir, se utiliza alguna otra medida (generalmente estocástica) distinta de los plazos para determinar la puntualidad. Esto puede incluir rendimiento promedio, tiempo promedio de ejecución, longitud máxima de ráfaga o alguna otra medida. Todos los sistemas pueden modelarse como sistemas estrictos en tiempo real, pero esto a menudo resulta en un “__sobrediseño__” del sistema para que sea más rápido o tenga más recursos disponibles de los necesarios, lo que aumenta el costo recurrente (aproximadamente el “costo de fabricación”) del sistema. 

Aunque todos los sistemas pueden modelarse como sistemas estrictos en tiempo real, en realidad la mayoría no lo son. Si la respuesta se retrasa ocasionalmente o incluso se pierde un evento de entrada completo, la mayoría de los sistemas seguirán funcionando correctamente. La razón principal para modelar sistemas en tiempo real como "difíciles" es porque facilita la garantía de la puntualidad del sistema a través del análisis matemático.

## Restricciones de diseño embebido

Desde el interior, una de las características más llamativas de los sistemas embebidos es la severidad de sus limitaciones. A diferencia del software de para una computadora de uso general, un sistema integrado generalmente se envía ya integrado con todo el hardware que necesita. La plataforma de hardware no suele ser extensible por el usuario, por lo que recursos como la memoria, la energía, la refrigeración o la potencia informática contribuyen al costo unitario (conocido como costo recurrente). Para mantener la rentabilidad, casi siempre existe una enorme presión sobre el desarrollador para minimizar el uso de dichos recursos de hardware. Esto significa que los sistemas embebidos a menudo requieren esfuerzos de optimización adicionales mucho más allá de los necesarios para las aplicaciones de escritorio.

Más allá de la necesidad de minimizar el hardware, las preocupaciones sobre el rendimiento suelen ser fundamentales para el éxito de un sistema. Hay muchos aspectos del rendimiento y los diferentes sistemas valoran estos aspectos de manera diferente. En algunos sistemas, el rendimiento es un criterio crítico. El rendimiento normalmente se mide en términos de la cantidad de transacciones, muestras, conexiones o mensajes que se pueden procesar por unidad de tiempo. En otros sistemas, es más importante manejar cada solicitud lo más rápido posible, una cualidad conocida como capacidad de respuesta, generalmente capturada como el peor tiempo de ejecución del caso.

Otros sistemas valoran la previsibilidad del rendimiento por encima del máximo rendimiento o capacidad de respuesta. La previsibilidad generalmente se mide como algo que ocurre dentro de un rango o como resultado de una función de densidad de probabilidad.

La confiabilidad, la robustez y la seguridad son otros tipos de limitaciones impuestas a los sistemas embebidos. La confiabilidad de un sistema es una medida (estocástica) de la probabilidad de que el sistema entregue la funcionalidad correcta. La robustez se refiere a la capacidad de un sistema para brindar servicios adecuadamente cuando se violan sus condiciones previas (como las condiciones operativas o las velocidades de datos de entrada). La seguridad denota el nivel de riesgo de un sistema, es decir, la probabilidad de que el uso del sistema resulte en un accidente o pérdida. Estas preocupaciones a menudo requieren medidas adicionales de hardware y software para mantener el funcionamiento del sistema dentro de límites aceptables. Por ejemplo, la mayoría de los sistemas integrados tienen una prueba automática de encendido (`POST`), así como una prueba integrada periódica o continua (`BIT`).
En conjunto, estas limitaciones del sistema se conocen como cualidades de servicios (`QoS`) proporcionadas por el sistema. Además de las diversas limitaciones de QoS, para reducir los costos recurrentes, es común crear hardware personalizado que requiere software de controlador de dispositivo especializado.

## La cadena de herramientas integrada

La mayoría de los sistemas integrados se crean en un sistema diferente (el "host") del que se ejecutan (el "destino"). Esto tiene varios efectos sobre el desarrollador y las herramientas utilizadas en la creación de sistemas integrados. La herramienta más obvia es el compilador cruzado. Este es un compilador que se ejecuta en el host pero crea código ejecutable que se ejecuta en una computadora y un entorno operativo diferentes. Muchos sistemas operativos en tiempo real (__RTOS__) proporcionan sus propios compiladores propietarios o personalizaciones para compiladores de código abierto como __GCC__ (_Gnu Compiler Collection_).

Un vinculador es un programa que combina un conjunto de códigos ejecutables en un ejecutable para un objetivo. Algunos sistemas operativos no requieren un paso de enlace explícito porque el cargador del sistema operativo vincula dinámicamente los elementos del programa a medida que se carga en la memoria. Esto es cierto para los sistemas operativos integrados estilo Unix, pero la mayoría de los sistemas operativos integrados requieren un paso de vinculación explícito. El vinculador a menudo también reubica el programa, lo que significa que la dirección de inicio se especifica durante el paso de vínculo y las instrucciones de salto en lenguaje ensamblador deben actualizarse para reflejar la dirección base de inicio real.

Un cargador es una herramienta que carga la salida de la imagen del objeto del paso de vinculación en la memoria del entorno de destino. Esto se puede hacer a través de un enlace serie o de red o grabando la imagen del software en una __memoria no volátil__ como Flash o EPROM. Como alternativa a cargar la imagen del software en una plataforma de destino, muchos desarrolladores utilizan simuladores para el objetivo que se ejecutan en sus sistemas de desarrollo host. Es común, por ejemplo, utilizar simuladores Z80 o 8051 que se ejecutan en Windows para comenzar a ejecutar, depurar y probar su software incluso antes de que las placas de destino estén disponibles.

Hasta ahora, las herramientas mencionadas en la cadena de herramientas se han limitado a introducir software en el sistema. Más allá de eso, debemos asegurarnos de que el software funcione correctamente. El siguiente conjunto de herramientas son los depuradores, herramientas que nos brindan una gran medida sobre la ejecución del software, incluida la capacidad de ingresar (ejecutar línea por línea) o pasar por alto (ejecutar en su totalidad) funciones, establecer puntos de interrupción y examinar. y modificar variables. Estos depuradores pueden funcionar a través de enlaces de red y serie estándar o a través de puertos JTAG.

Los entornos de desarrollo integrados (IDE) de hoy en día vinculan la mayoría o todas las herramientas en la cadena de herramientas integradas para facilitar y automatizar el proceso de desarrollo. La última tendencia de la industria es alojar los IDE en la plataforma __Eclipse__ debido al poder del entorno integrado y la disponibilidad de complementos de código abierto y de terceros. La _Jazz Foundation_ lleva la plataforma Eclipse un paso más allá para integrar gestión, medición, generación de informes y otras herramientas para respaldar mejor el desarrollo y la entrega de software colaborativo.